# パスワード・認証
## 概要（当初版）
情報セキュリティで確保すべき機密性の根拠は認証である。認証の種類と特徴について、主にパスワードを例として述べる。また、シングル・サインオン（SSO）についても述べる。

## キーワード（当初版）
認証、パスワード

## 概要（学習のポイント）＜改訂版＞

## キーワード＜改訂版＞


# 認証とは
インターネットを介してサービスを享受することが当たり前になった現代では、遠隔にあるサービス事業者に対して自分が何者であるかを主張しサービス事業者に本人性を確認してもらう __認証（Authentication）__ が重要な位置を占めている。

本人性確認の必要性は古来から存在していたが、情報通信が盛んになった時代において遠隔から通信路を通じて接続することが多くなってきたため、
認証の重要性が非常に高くなってきた。
認証の技術はパスワードによる認証を中心にさまざまな技術が利用され、多岐にわたる認証技術が我々の生活において利用可能となっている。

ここでは現在情報技術と共に利用される認証技術について解説をする。

# 認証の種類と特徴

## 認証の要素
多岐にわたる認証技術は、認証に用いられる要素により3つに分類することができる。

1. Something you know（対象とする人が知っている何か、記憶による認証）
1. Something you have（対象とする人が持っているか何か、所持による認証）
1. Something you are（対象とする人が何か、本人の特徴による認証）

"Something you know"は認証される個人が持つ記憶により認証する技術であり、パスワードやPIN（Personal Identification Number）などがそれにあたる。
"Something you have"は認証される個人が所持するなんらかの物理的な物を用いた認証であり、ICカードや運転免許証などがそれにあたる。
"Something you are"は本人の特徴による認証であり、指紋認証や顔認証などがそれにあたる。
認証手段はこれらの3つの要素のうち1つ以上を持ち実現される。

## 多岐にわたる認証の種類
記憶による認証では、対象となる人が記憶している文字列を利用し認証を行うパスワード認証が代表的な手法である。文字や記号も利用できるパスワードに対し、数字だけで構成されるPINもPCやデバイスへのログイン等に用いられることが多い。

所持による認証では、ICカードやトークンなど個人に配付されたデバイスを用いて認証を行う手法が代表的である。

本人の特徴による認証としては、指紋認証や顔認証など本人の生体情報を用いた認証や、行動特性を利用した認証方法などがある。
生体情報を読み取るデバイスが安価かつ小型化されたこともありスマートフォンやラップトップPCなど利用が広まっている。


## リモート認証とローカル認証
認証方法は認証される本人と認証をするシステムの位置関係により分類することもできる。
通信路を隔てて遠隔先のサーバ等にアクセスするための認証をリモート認証と呼び、
PCのログインやスマートフォン端末のロック解除のための認証をローカル認証と呼ぶ。

リモート認証とローカル認証ではその特性の違いからリスクも異なるため、リスクに応じた認証方法が選択される。
リモート認証では認証のための情報が遠隔のサーバ上に置かれるが、ローカル認証ではPCやスマートフォン自体に認証のための情報が置かれる。
リモート認証の場合は認証のための情報が遠隔へと送信されサーバ上で本人性の確認作業が行われるため、その途中経路において第3者に覗き見されるなどの漏洩が避けられなければならない。通信路の暗号化や、ハッシュ値などを利用した対策が行われる。
一方、ローカル認証の場合は認証のための情報は端末内部だけで処理されるため、第3者による覗き見のリスクはリモート認証に比べて低くなる。

認証のための情報の管理も違いがある。
リモート認証の情報はサーバ側に置かれるため、サーバ側で起こるアクシデント等で漏洩することがあるなどのリスクがある。
サーバ側に置かれる情報は暗号化やハッシュ化など認証情報がそのままで置かれることの内容に処理がされて管理される。
生体認証では認証の方法と用いられる生体情報によっては登録した情報を変更することが不可能であるため、サーバ側で漏洩してしまうと重大なリスクとなる場合がある。ローカル認証として生体認証がされるほうがリスクを抑えた利用方法であると言えよう。


## 多要素認証
銀行口座の振込がオンラインで可能なサービスと、ゲームのように匿名のユーザ名で利用可能なサービスでは、本人性に起因したリスクが異なるために認証に求められる本人性確認の厳格さが異なってくる。
本人性確認の厳格さ向上のために高度な認証技術を利用するという手段もあるが、その他に複数の認証要素を用いてより本人確認を確実にする手段もある。

複数の認証要素を用いて本人確認する方法を多要素認証（Multi Factor Authrntication）と呼ぶ。
2つの要素を用いることが多いため、2要素認証と呼ばれることもある。
たとえば、銀行ATM利用におけるキャッシュカードと暗証番号はキャッシュカードの所持という要素と暗証番号という記憶という要素の2要素を用いた認証になっている。リモート認証の場合であれば、暗号鍵を格納したデバイスに対してパスワードあるいは指紋認証等の生態認証により暗号鍵利用のアクティベートし、暗号鍵を利用して遠隔のサーバと認証作業を行う手法などがある。

# パスワード
記憶による認証の代表的な手法であるパスワードは、情報通信が盛んになる前から広く利用されてきた。
情報通信が発達しインターネットが一般的になると、特殊なシステムを要しないことなどから認証方式としてさらに採用が進んだ。現在でも広く用いられている。

ユーザに文字列を記憶される方式としてはその他に、一般的に数字列だけを用いて認証するPIN方式や、複数のキーワードを組み合わせるパスフレーズなども存在するが、ここではそれらはパスワードとしてまとめた扱うこととする。

## パスワードによる認証の流れ
パスワードを用いた認証の流れを図1に示す。

![Figure1](figure01.png)

認証サーバは登録されたユーザのIDと登録パスワードをデータベースで管理しています。
認証を行う場合、まず最初にAliceは自分自身のIDと記憶しているパスワードをシステムに入力します（図1の①）。次に認証サーバは入力されたIDから登録されているパスワードをデータベースより探しだし、Aliceより入力されたパスワードと比較を行い一致するかどうかを確認します（図1の②）。
そしてその結果をユーザに返します（図1の③）。

基本的な流れは図1の通りであるが、実際のシステムではさらに対策がされている。たとえば図1の①では、Aliceが入力したパスワードが通信路上に流れるために第3者に覗き見される可能性がある。覗き見を避けるために通信路の暗号化が行われることが一般的である。Webを用いたシステムでは第3章で解説するTLSが用いられることが多い。
認証サーバが持つデータベースにも対策が行われる。ユーザが登録したパスワードがそのまま登録されているデータベースは、なんらかのアクシデント等でサーバのデータベースが漏洩した場合にユーザのパスワードが漏れてしまう恐れがある。パスワード漏洩のリスクを避けるために、保管される情報はパスワードのハッシュ値が置かれることが多い。詳細は後述する「パスワードの管理」で解説する。

## パスワード認証の応用

図1で示した基本的なパスワード認証では、通信路の暗号化によりパスワード自身が第3者に覗き見されることに対応されることがあるが、他の手段も存在する。
チャレンジレスポンス方式では、認証を求めたユーザに対しサーバ側がまずチャレンジと呼ばれるランダムな情報をユーザに渡す。
チャレンジを受け取ったユーザは、決められた手続きにより自身のパスワードを用いてそのチャレンジを加工して（これをレスポンスと呼ぶ）サーバに返す。
サーバ側は、送ったチャレンジを手元で計算し正解となるレスポンスを生成し、ユーザから送られてきたレスポンスと比較をして一致するかを確認する。
この手法を用いた場合、通信路に流れる情報はチャレンジとレスポンスだけになりパスワードそのものは流れなくなるため、パスワードを保護する手段の1つとして利用することができる。

またその応用として、ワンタイムパスワードトークンと呼ばれる端末や同等の機能を持つアプリケーションを用意し、一定時間ごとに表示される情報などを入力することで本人性を確認する手段もある。この場合、トークンとサーバ側の時計が同期されることで入力されるべき情報が共有される。


## パスワードの生成

ユーザ自身がパスワードの生成を行い登録する場合、生成されるパスワードの性質はしばしば偏る。
最も多いパスワードは"123456"であることは良く知られているが、その他にも人間の特性としてランダムなパスワードではなく記憶しやすいパスワードが選ばれてしまうことがこれまでの研究で広く知られてきた。
そういったパスワードは第3者から推測がしやすいためになりすましによるログインとその後の情報漏洩などのリスクが高くなる。

サービス提供の側はそういった弱いパスワードの登録を避けるためにさまざまな手段を講じている。
ユーザが設定するパスワードの構成に制限を付けるパスワード構成ポリシーは、ユーザが設定するパスワードの構成に制限を付ける。たとえばパスワードの最低の長さを8文字とすることや、パスワードの中にかならず記号を含ませることや、必ず数値を含ませることなどの種類がある。
パスワード構成ポリシーの利用は多くのサービスで行われており、制限種類を複数かけ合わせた複雑な制限を課す事例も多いが、これまでの研究でそれらの効果の高さは思ったより高くないことが示されている。むしろより長いパスワード長にすることや、推測されやすい単語などを利用しないことの効果が高いことが示されている。
その結果、従来では複雑な制限を加えることが推奨されてきたが最近ではより長いパスワードを実現すべく、複数の単語を繋ぎ合わせるようなパスフレーズの導入が推奨されることも増えてきている。


パスワード生成時にそのパスワードの強度を計算しフィードバックを与えるインターフェースもよく利用される。
たとえばパスワードの強度をスコア化しそのスコアを表示する方法や、メーター表示にしてその強度を視覚的に伝える方法、赤・オレンジ・黄色・緑と強度が高くなるにつれ色を変更させる方法など多岐にわたる。これらのフィードバックは利用者に心理的負担を与えずに生成されるパスワードの強度を上げる効果があることが知られている。


## パスワードの管理
パスワードによる認証は導入の容易さから広く利用されている一方で、適切な管理がされないとパスワードの漏えいやなりすましのリスクが高まる。
管理はユーザ側とサーバ側の双方でされることで適切な利用がされる。
ここではそれぞれの側で行われるべき管理手法について解説する。

### ユーザ側の管理

一般的に、利用者はインターネットを通じて様々なサービスを利用する。そのサービスでは多くがユーザ登録を必要とし、認証にパスワードを用いている。
その結果、ユーザは複数のユーザIDとパスワードを管理することとなる。
こういったケースでは、人間の行動特性として複数サービスで共通のユーザIDとパスワードを設定してしまうことがある。しかしこれらはリスクが高いために避けられるべきである。あるサービスが何らかの理由により利用者IDとパスワードを漏えいさせてしまった場合、それらの情報が悪用され他のサービスへの認証試行として用いられることがある。こういった攻撃はパスワードリスト攻撃と呼ばれ、実際に多くの被害事例が報告されている。

一方で、人間が記憶可能な情報には限りがあり、すべてのサービスで異なるIDとパスワードを設定しそれを明確に記憶しておくことは難しい。
仮に異なるパスワードを設定したとして、それぞれのパスワードが記憶しやすいパスワードに傾くことも充分に考えられる。そうなった場合、各パスワードの強度が下がり、なりすましのリスクは上がる。
多くのユーザIDとパスワードを管理するパスワード管理ツールはそういった困難性を低減させることが可能である。
パスワード管理ツールにユーザIDとパスワードの情報が集約されることから高い信頼性が求められるツールであり、そのツールに脆弱性があることで情報漏えいが発生するリスクはあるものの、多数のIDとパスワードの管理をユーザ自らが行うことの難しさやそれに付随するリスクと比較すればツール利用の管理が望ましいと言える。

パスワードの使いまわしや強度の低いパスワード設定への対策として、サービス提供側がパスワードに有効期限を設けて定期的にパスワード変更を促す仕組みがある。これらはこれまで多くのサービスで採用されていたが、これまでの調査によりその効果が高くないことがしめされ、現在ではサービス提供者による変更の強制は推奨されないものとなっている。

パスワード設定時にパスワード以外に秘密の質問と答えを登録し、パスワードを忘れた場合にその質問に答えされるような仕組みも多く提供されていたが、こちらも効果が薄いことや逆にリスクが高まることが指摘され、現在では推奨されないものとなっている。


### サーバ側の管理

図1に示したパスワード認証の流れでは、サーバ側がユーザIDと登録パスワードのデータベースを保持していた。
先述した通り、ユーザが登録したパスワードがそのまま登録されているデータベースはなんらかのアクシデントでデータベースが漏洩した場合にユーザのパスワードが漏れてしまう恐れがある。
そこでパスワードを暗号学的一方向性関数（暗号学的ハッシュ関数）を利用しパスワードのハッシュ値を得、そのハッシュ値をデータベースに保存することで漏えいした場合の対応を行う。
暗号学的ハッシュ関数は入力された情報からハッシュ値を計算する一方向性を持った関数であり、ハッシュ値から元の入力情報を計算することが困難なように設計されている。

図2にハッシュ関数を用いたサーバ側のパスワード管理の概要を示す。
まずパスワードの登録時にサーバ側はパスワードのハッシュ値を計算しデータベースに登録する。
認証時にはユーザから入力されたパスワードのハッシュ値を計算し（図2の②）、その値がデータベースに保存されている値と同じであるかを確認する（図2の③）。
登録されたパスワードと入力されたパスワードが同じであればハッシュ値も同じになるために、ハッシュ値が同じであるかを確認することで入力されたパスワードが正しいことが確認できる。
万が一サーバ側のデータベースが漏えいしても、ハッシュ値だけを手に入れた第3者はその情報から元のパスワードを推測するのが難しいため、なりすましやパスワードリスト攻撃のリスクは高くない。

![Figure1](figure02.png)

ハッシュ値によるパスワード保管はさらに工夫がされている。
ハッシュ関数の特性により、同じ入力には必ず同じ出力がされる。たとえば"123456"のハッシュ値が”8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92”であることがすでにわかっている場合、漏えいしたハッシュ値のデータベースの中にこのデータが存在した場合、そのユーザのパスワードが"123456"であることがわかってしまう。
悪意のある第3者が代表的なパスワードとそのハッシュ値のリストを持っていた場合、漏えいしたハッシュ値のリストから元のパスワードを得ることが可能になってしまうリスクが発生する。
こういったリスクへの対策として、ソルト（salt）の利用が行われる。
ソルトはハッシュ値を計算するパスワードに追加される文字列のことであり、サーバ側にはソルトとパスワードを連結したデータから得たハッシュ値がソルトと共に保管される。この場合、パスワードが"123456"と同じであってもソルトが異なれば全く違うハッシュ値になる。
仮にソルト付きのハッシュ値が漏えいした場合でも、ソルト付きのハッシュ値の入力となったパスワードが"123456"であることは推測が困難であり、代表的なパスワードそれぞれに対して考えうるソルトのパターンすべてでハッシュ値のリストを持つことはデータ量や生成負荷を考えると困難であるため、リスクが低減する。

パスワードのハッシュ値からパスワードを推測する方法として、考えうるパスワードのハッシュ値を全て求める総当たりの攻撃がある。
現在広く使われているSHA-1やSHA-256といった暗号学的ハッシュ関数はその出力が160ビットあるいは256ビットであるために総当たりを行うにはそれぞれ2の160乗あるいは2の256乗の回数が必要となり現時点では現実的ではない。
一方でそういったハッシュ関数の計算に必要となる計算能力が将来的に向上した場合には総当たり攻撃が現実的になる可能性もある。
そこで総当たり攻撃のリスクをさらに低減するためにストレッチングが採用されることもある。
ストレッチングでは、ハッシュ関数による計算を1回だけ用いるのではなく1000回や10000回など複数回行った結果をハッシュ値として保管、比較する。
これにより計算時間は増加するため、総当たり攻撃を行う攻撃者への対策となる。
登録時や毎回の認証時にサーバの負荷が上がることや認証時間が増加することになるが、サーバ側の負担ならないようにストレッチングの回数が調整される。


# 認証と認可
日本語に一般的に利用される認証という言葉は様々な意味を持ちうる。
アクセスしてきている相手が誰かを判断することも認証と呼んだり、確認された相手に対してアクセスを許可することも認証の意味に含むことがある。
時には、なにかの確認をしたことさえ「認証した」ということもある。

情報技術においてはこれらは認証とは別の言葉として明確に定義がされている。
本書では認証を「自分が何者であるかを主張しサービス事業者に本人性を確認してもらう」と定義している。
一般的なシステムにおいては、サーバ側はアクセスしてきたユーザの認証を行った後にそのユーザの持つ権限に応じたサービスの提供を行う。
ユーザは権限に応じてサービスのデータやネットワークなどのリソースを利用できる。こういったユーザ権限に応じたリソースに対するアクセス制限を認可（Authorization）と呼ぶ。
認証と認可は密接な関係にあるが、別のものとして認識することが重要である。
たとえば、認証せずに認可するというケースもある。
アクセスした時間がある特定の時間帯であればだれでもアクセスできるというようなサービスの場合は、それは認証は行っていないが認可は行っていることとなる。。

認証と認可を明確に区別することにより、ユーザIDの管理とリソースへのアクセス権限の管理が分離され、組織内における認証の統一化や組織間にまたがるリソースアクセスの認可機構などが実現されるようになる。

# シングルサインオン
認可を利用して、1度認証を受ければ複数の別々のサービスのリソースが利用可能にすることができる。
たとえば1度認証を受けた後、認証されたことを示すIDトークンを発行してもらい、そのトークンをそれぞれのサービスに提示することでそれぞれのサービスでは認証をせずともリソース利用の認可を得られるような仕組みがある。
こういった1度の認証により複数のサービスのリソースを利用できる仕組みは総称してシングルサインオン（Single Sign On、SSO）と呼ばれるが、その実現技術は複数の手段がある。

たとえば、各サービスのサーバにはそれぞれ異なったユーザIDとパスワードが設定されているが、それらに対する認証を代理で行うサーバを用意し、ユーザはその代理サーバにアクセスをして認証されることでユーザの視点では1度の認証で複数のサービスを受けられるようになる仕組みがある。
こういった代理認証の方式ではユーザから見える部分が統一化されているが、実際のプロトコルではこれまでと同様の認証作業が動いている。

組織内に複数のサービスがある場合にそれぞれのサービスでユーザIDとパスワードを管理するのではなく、組織内のユーザIDとパスワードを統合的に管理するサーバを用意し、各サービスは統合管理サーバよりIDとパスワードの情報を提供されるという仕組みもある。
統合ID管理サーバは認証を受け持ち、1度認証をされたらユーザ側の端末にトークンを配布し各サービスにアクセスするときにトークンを提示することで認証せずともサービスが利用になる。
代理認証の方法とは異なり、認証作業自体は1度となりそれ以外の通信ではトークンの提示により認可がされる方法となっている。
WindowsのActive Directoryなどはこういった方法が採用されているが、組織内のサービスだけに限定されるという特徴があった。

近年では、組織内にサービスを立ち上げるだけでなく、さまざまなクラウドコンピューティング事業者が提供するサービスを業務として利用することも多くなった。しかし先述の例では1度の認証でそれらクラウドサービスまで含んだ連携は実現されなかった。
そこでさらに多くの技術が開発され、組織を超えたシングルサインオンが実現されるようになった。
IDを統合することをせず、それぞれのIDを連携させることで認証サーバによる認証後は連携されるサービスを利用可能にするSAMLやOpenIDなどのIDや認証の連携技術が現在では広く利用されている。
認証の連携後はそれぞれのサービスのおいて適切な認可が必要となるが、そこではOAuthなどの技術が現在では広く利用されている。
